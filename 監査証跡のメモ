監査証跡

DRF＋Vuejsでファイルに監査証跡のログを出力したいって時はミドルウェア＋シグナル＋settingsにlog系追加？したら、既存の環境壊さずにいけるんかな？(´・ω・｀)


🔍 監査証跡ログの実装方法！
既存環境を壊さずに実装できるよ！(　･ω･)b

🎯 推奨アーキテクチャ
┌─────────────────────────────────────┐
│  DRF (Backend)                      │
├─────────────────────────────────────┤
│  ① Middleware (リクエスト/レスポンス) │  ← 全APIの出入り口
│  ② Signal (モデル操作)               │  ← CRUD操作
│  ③ Custom Logging (業務ロジック)     │  ← 重要処理
│  ④ settings.py (ログ設定)            │  ← 出力先・フォーマット
└─────────────────────────────────────┘
         ↓ JSON形式でログ出力
┌─────────────────────────────────────┐
│  logs/audit.log                     │  ← ファイル出力
└─────────────────────────────────────┘
```

---

## 📁 実装ファイル構成
```
backend/
├── config/
│   ├── settings.py              # ⭐ ログ設定追加
│   └── middleware.py            # ⭐ 新規作成
├── common/
│   ├── audit.py                 # ⭐ 新規作成（監査ログ用ヘルパー）
│   └── signals.py               # ⭐ 新規作成（モデル監査）
├── logs/                        # ⭐ 新規作成（ログ出力先）
│   ├── audit.log
│   └── .gitignore
└── users/
    └── signals.py               # ⭐ 既存のシグナルに追加

🔧 実装手順
1️⃣ settings.py にログ設定追加
python# backend/config/settings.py

import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

# ==================== ログ設定（既存を壊さない） ====================

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # ⭐ 既存ログを無効化しない
    
    'formatters': {
        # 通常ログ用（既存）
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
        # ⭐ 監査ログ用（JSON形式）
        'audit_json': {
            'format': '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "user": "%(user)s", "action": "%(action)s", "model": "%(model)s", "object_id": "%(object_id)s", "ip": "%(ip)s", "changes": %(changes)s, "message": "%(message)s"}',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
    },
    
    'handlers': {
        # 既存のコンソール出力（変更なし）
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        # ⭐ 監査ログ専用ハンドラー
        'audit_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'audit.log',
            'maxBytes': 10 * 1024 * 1024,  # 10MB
            'backupCount': 10,  # 過去10ファイル保持
            'formatter': 'audit_json',
        },
    },
    
    'loggers': {
        # Django標準ログ（既存）
        'django': {
            'handlers': ['console'],
            'level': 'INFO',
        },
        # ⭐ 監査ログ専用ロガー
        'audit': {
            'handlers': ['audit_file'],
            'level': 'INFO',
            'propagate': False,  # 親ロガーに伝播させない
        },
    },
}

# ==================== ミドルウェア設定 ====================

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'config.middleware.AuditMiddleware',  # ⭐ 追加
]

2️⃣ ミドルウェア作成（API監査）
python# backend/config/middleware.py
"""
API監査ミドルウェア

役割:
- すべてのAPIリクエスト/レスポンスをログ記録
- ログイン/ログアウトを記録
- エラーレスポンスを記録
"""

import logging
import json
from django.utils.deprecation import MiddlewareMixin
from django.contrib.auth import get_user_model

User = get_user_model()
audit_logger = logging.getLogger('audit')


class AuditMiddleware(MiddlewareMixin):
    """API監査ミドルウェア"""
    
    # 監査対象のパス（必要に応じて追加）
    AUDIT_PATHS = [
        '/api/auth/login/',
        '/api/auth/logout/',
        '/api/users/',
    ]
    
    # 除外パス（ヘルスチェックなど）
    EXCLUDE_PATHS = [
        '/api/health/',
        '/api/csrf/',
    ]
    
    def process_request(self, request):
        """リクエスト前処理"""
        # 監査対象かチェック
        if not self._should_audit(request):
            return None
        
        # リクエスト情報を保存（レスポンス時に使用）
        request._audit_data = {
            'method': request.method,
            'path': request.path,
            'user': self._get_user_info(request),
            'ip': self._get_client_ip(request),
        }
        
        return None
    
    def process_response(self, request, response):
        """レスポンス後処理"""
        # 監査データがない場合はスキップ
        if not hasattr(request, '_audit_data'):
            return response
        
        # ログ記録
        audit_data = request._audit_data
        
        # ⭐ ログイン成功
        if request.path == '/api/auth/login/' and response.status_code == 200:
            self._log_audit(
                user=audit_data['user'],
                action='LOGIN',
                model='Auth',
                ip=audit_data['ip'],
                message='ユーザーがログインしました',
            )
        
        # ⭐ ログアウト
        elif request.path == '/api/auth/logout/' and response.status_code == 200:
            self._log_audit(
                user=audit_data['user'],
                action='LOGOUT',
                model='Auth',
                ip=audit_data['ip'],
                message='ユーザーがログアウトしました',
            )
        
        # ⭐ API操作（POST/PUT/PATCH/DELETE）
        elif request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:
            action_map = {
                'POST': 'CREATE',
                'PUT': 'UPDATE',
                'PATCH': 'UPDATE',
                'DELETE': 'DELETE',
            }
            
            self._log_audit(
                user=audit_data['user'],
                action=action_map[request.method],
                model=self._extract_model_name(request.path),
                ip=audit_data['ip'],
                message=f'{request.method} {request.path}',
                extra={
                    'status_code': response.status_code,
                }
            )
        
        return response
    
    def _should_audit(self, request):
        """監査対象かチェック"""
        # 除外パス
        if any(request.path.startswith(path) for path in self.EXCLUDE_PATHS):
            return False
        
        # 監査対象パス
        return any(request.path.startswith(path) for path in self.AUDIT_PATHS)
    
    def _get_user_info(self, request):
        """ユーザー情報取得"""
        if request.user.is_authenticated:
            return {
                'id': request.user.id,
                'employee_id': request.user.employee_id,
                'username': request.user.username,
            }
        return {'id': None, 'employee_id': 'anonymous', 'username': 'anonymous'}
    
    def _get_client_ip(self, request):
        """クライアントIP取得"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            return x_forwarded_for.split(',')[0]
        return request.META.get('REMOTE_ADDR')
    
    def _extract_model_name(self, path):
        """パスからモデル名を抽出"""
        if '/users/' in path:
            return 'User'
        return 'Unknown'
    
    def _log_audit(self, user, action, model, ip, message, extra=None):
        """監査ログ出力"""
        audit_logger.info(
            message,
            extra={
                'user': user.get('employee_id', 'anonymous'),
                'action': action,
                'model': model,
                'object_id': extra.get('object_id') if extra else None,
                'ip': ip,
                'changes': json.dumps(extra) if extra else '{}',
            }
        )

3️⃣ シグナルでモデル操作を監査
python# backend/common/signals.py
"""
モデル監査シグナル

役割:
- モデルのCRUD操作を自動記録
- 変更内容を詳細に記録
"""

import logging
import json
from django.db.models.signals import post_save, post_delete, pre_save
from django.dispatch import receiver
from django.contrib.auth import get_user_model

User = get_user_model()
audit_logger = logging.getLogger('audit')


@receiver(pre_save, sender=User)
def user_pre_save(sender, instance, **kwargs):
    """ユーザー更新前（変更内容を記録）"""
    if instance.pk:  # 更新の場合
        try:
            old_instance = User.objects.get(pk=instance.pk)
            instance._old_values = {
                'username': old_instance.username,
                'employee_id': old_instance.employee_id,
                'is_admin': old_instance.is_admin,
                'is_active': old_instance.is_active,
            }
        except User.DoesNotExist:
            pass


@receiver(post_save, sender=User)
def user_post_save(sender, instance, created, **kwargs):
    """ユーザー作成/更新後"""
    action = 'CREATE' if created else 'UPDATE'
    
    # 変更内容を抽出
    changes = {}
    if not created and hasattr(instance, '_old_values'):
        old = instance._old_values
        changes = {
            field: {'old': old[field], 'new': getattr(instance, field)}
            for field in old.keys()
            if old[field] != getattr(instance, field)
        }
    
    # ログ記録
    audit_logger.info(
        f'User {action}: {instance.username}',
        extra={
            'user': 'system',  # システム操作（リクエスト外）
            'action': action,
            'model': 'User',
            'object_id': instance.id,
            'ip': '127.0.0.1',
            'changes': json.dumps(changes) if changes else '{}',
        }
    )


@receiver(post_delete, sender=User)
def user_post_delete(sender, instance, **kwargs):
    """ユーザー削除後"""
    audit_logger.info(
        f'User DELETE: {instance.username}',
        extra={
            'user': 'system',
            'action': 'DELETE',
            'model': 'User',
            'object_id': instance.id,
            'ip': '127.0.0.1',
            'changes': '{}',
        }
    )

4️⃣ シグナル登録
python# backend/users/apps.py

from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users'
    
    def ready(self):
        """⭐ シグナル登録"""
        import common.signals  # noqa

5️⃣ logs ディレクトリ作成
bash# ターミナルで実行
mkdir backend/logs
touch backend/logs/.gitignore
gitignore# backend/logs/.gitignore
*.log
!.gitignore

📊 ログ出力例
json{"timestamp": "2025-10-19 15:30:45", "level": "INFO", "user": "9999", "action": "LOGIN", "model": "Auth", "object_id": null, "ip": "192.168.1.100", "changes": {}, "message": "ユーザーがログインしました"}
{"timestamp": "2025-10-19 15:31:10", "level": "INFO", "user": "9999", "action": "CREATE", "model": "User", "object_id": 5, "ip": "192.168.1.100", "changes": {}, "message": "POST /api/users/"}
{"timestamp": "2025-10-19 15:32:00", "level": "INFO", "user": "system", "action": "UPDATE", "model": "User", "object_id": 5, "ip": "127.0.0.1", "changes": {"is_active": {"old": true, "new": false}}, "message": "User UPDATE: 山田太郎"}
```

---

## ✅ 既存環境への影響チェック

| 項目 | 影響 | 理由 |
|-----|------|------|
| **既存ログ** | ✅ 影響なし | `disable_existing_loggers=False` |
| **パフォーマンス** | ⚠️ 微増 | ミドルウェア処理が追加されるため |
| **既存API** | ✅ 影響なし | レスポンス内容は変更なし |
| **データベース** | ✅ 影響なし | ファイル出力のみ |

---

## 🚀 段階的導入プラン
```
Phase 1: ログ設定のみ追加
  → settings.py だけ変更して動作確認

Phase 2: ミドルウェア追加
  → ログイン/ログアウトのみ記録

Phase 3: シグナル追加
  → モデル操作も記録

Phase 4: カスタムログ追加
  → 業務ロジックの重要処理を記録

こんな感じで 段階的に導入 すれば既存環境を壊さずに実装できるよ！(　･ω･)b✨


*****************************************************************************************************************


cloud君の回答は正しい(´・ω・｀)？
これでできるんかね？監査証跡ログ

ほぼ正しいけど、いくつか 要注意ポイント があるよ！(´・ω・｀)

✅ 正しい部分
アーキテクチャ: ミドルウェア + シグナル + settings.py の組み合わせは王道
段階的導入: 既存環境を壊さない進め方も正解
ログローテーション: RotatingFileHandlerで10MB/10ファイル保持も妥当
⚠️ 修正が必要な部分
1. ログフォーマッターが動かない
python
# ❌ このJSON形式は正しく動かない
'format': '{"timestamp": "%(asctime)s", ...}'
Pythonの標準loggingでは、extraフィールドは自動的にフォーマット文字列に展開されない。 %(user)sとか%(action)sを使うには、カスタムフォーマッター or Filterが必要。

修正案:

python
# backend/common/formatters.py
import json
import logging

class AuditJSONFormatter(logging.Formatter):
    def format(self, record):
        log_data = {
            'timestamp': self.formatTime(record),
            'level': record.levelname,
            'user': getattr(record, 'user', 'unknown'),
            'action': getattr(record, 'action', ''),
            'model': getattr(record, 'model', ''),
            'object_id': getattr(record, 'object_id', None),
            'ip': getattr(record, 'ip', ''),
            'changes': getattr(record, 'changes', '{}'),
            'message': record.getMessage(),
        }
        return json.dumps(log_data, ensure_ascii=False)
python
# settings.py
'formatters': {
    'audit_json': {
        '()': 'common.formatters.AuditJSONFormatter',  # ⭐ カスタムフォーマッター
        'datefmt': '%Y-%m-%d %H:%M:%S',
    },
}
2. ミドルウェアで request.user が取れない場合がある
AuthenticationMiddleware の 後 に配置しないと、request.user が AnonymousUser のまま。

python
MIDDLEWARE = [
    ...
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # ⭐ この後に配置
    'config.middleware.AuditMiddleware',  # ⭐ ここ
]
3. シグナルでリクエストユーザーが取れない
python
'user': 'system',  # ❌ 誰が操作したか分からない
シグナル内では request にアクセスできないから、スレッドローカル で渡す必要がある。

修正案:

python
# backend/common/context.py
import threading

_request_local = threading.local()

def set_current_request(request):
    _request_local.request = request

def get_current_request():
    return getattr(_request_local, 'request', None)
python
# middleware.py
from common.context import set_current_request

class AuditMiddleware(MiddlewareMixin):
    def process_request(self, request):
        set_current_request(request)  # ⭐ リクエストを保存
        ...
python
# signals.py
from common.context import get_current_request

@receiver(post_save, sender=User)
def user_post_save(sender, instance, created, **kwargs):
    request = get_current_request()
    user_info = 'system'
    ip = '127.0.0.1'
    
    if request and request.user.is_authenticated:
        user_info = request.user.employee_id
        ip = get_client_ip(request)  # ⭐ 実際のIPを記録
    
    audit_logger.info(..., extra={'user': user_info, 'ip': ip, ...})
4. パスワード変更が平文でログに残る危険性
python
changes = {'password': {'old': 'xxx', 'new': 'yyy'}}  # ❌ 超危険
対策:

python
SENSITIVE_FIELDS = ['password', 'token', 'secret']

if not created and hasattr(instance, '_old_values'):
    changes = {
        field: {'old': '***', 'new': '***'} if field in SENSITIVE_FIELDS
               else {'old': old[field], 'new': getattr(instance, field)}
        for field in old.keys()
        if old[field] != getattr(instance, field)
    }
🎯 結論
cloud君の回答は 8割正解 だけど、上記の修正をしないと：

❌ JSONフォーマットが崩れる
❌ シグナルで操作ユーザーが取れない
❌ パスワードが平文でログに残る
修正版を実装すれば、バッチリ動くよ！(｀･ω･´)b


これって全モデルを監視して記録してくれてるってこと？

いや、違う！ このコードは Userモデルだけ しか監視してないよ(´・ω・｀)

📍 現状の監視範囲
python
# ❌ Userモデルのみ
@receiver(post_save, sender=User)
@receiver(pre_save, sender=User)
@receiver(post_delete, sender=User)
他のモデル（例: 商品、注文、在庫など）は 一切記録されない。

🎯 全モデルを監視する方法
方法1: モデルごとにシグナルを書く（明示的）
python
# signals.py
from products.models import Product
from orders.models import Order

@receiver(post_save, sender=Product)
def product_post_save(sender, instance, created, **kwargs):
    # Productの監査ログ
    ...

@receiver(post_save, sender=Order)
def order_post_save(sender, instance, created, **kwargs):
    # Orderの監査ログ
    ...
メリット: 柔軟（モデルごとに記録内容を変えられる）
デメリット: モデルが増えるたびにコード追加が必要

方法2: 全モデルに自動適用（汎用的）★推奨
python
# backend/common/signals.py
import logging
import json
from django.apps import apps
from django.db.models.signals import post_save, post_delete, pre_save
from django.dispatch import receiver
from common.context import get_current_request, get_client_ip

audit_logger = logging.getLogger('audit')

# ⭐ 監査対象外のモデル
EXCLUDE_MODELS = [
    'contenttypes.ContentType',
    'sessions.Session',
    'admin.LogEntry',
]

# ⭐ 機密フィールド（ログに残さない）
SENSITIVE_FIELDS = ['password', 'token', 'secret_key', 'api_key']


def should_audit(model):
    """監査対象かチェック"""
    model_label = f"{model._meta.app_label}.{model._meta.model_name}"
    return model_label not in EXCLUDE_MODELS


def get_field_changes(old_instance, new_instance):
    """変更内容を抽出"""
    changes = {}
    
    for field in new_instance._meta.fields:
        field_name = field.name
        
        # 機密フィールドはマスク
        if field_name in SENSITIVE_FIELDS:
            if getattr(old_instance, field_name) != getattr(new_instance, field_name):
                changes[field_name] = {'old': '***', 'new': '***'}
            continue
        
        # 通常フィールド
        old_value = getattr(old_instance, field_name)
        new_value = getattr(new_instance, field_name)
        
        if old_value != new_value:
            changes[field_name] = {
                'old': str(old_value),
                'new': str(new_value)
            }
    
    return changes


def log_audit(action, instance, changes=None):
    """監査ログ出力"""
    request = get_current_request()
    
    user_info = 'system'
    ip = '127.0.0.1'
    
    if request and hasattr(request, 'user') and request.user.is_authenticated:
        user_info = getattr(request.user, 'employee_id', request.user.username)
        ip = get_client_ip(request)
    
    audit_logger.info(
        f'{instance._meta.model_name} {action}: {instance.pk}',
        extra={
            'user': user_info,
            'action': action,
            'model': instance._meta.model_name.capitalize(),
            'object_id': instance.pk,
            'ip': ip,
            'changes': json.dumps(changes or {}, ensure_ascii=False),
        }
    )


# ⭐ 全モデルに適用
def register_audit_signals():
    """全モデルにシグナルを登録"""
    
    for model in apps.get_models():
        if not should_audit(model):
            continue
        
        # pre_save: 更新前の値を保存
        @receiver(pre_save, sender=model, weak=False)
        def model_pre_save(sender, instance, **kwargs):
            if instance.pk:
                try:
                    old = sender.objects.get(pk=instance.pk)
                    instance._old_instance = old
                except sender.DoesNotExist:
                    pass
        
        # post_save: 作成/更新を記録
        @receiver(post_save, sender=model, weak=False)
        def model_post_save(sender, instance, created, **kwargs):
            action = 'CREATE' if created else 'UPDATE'
            changes = {}
            
            if not created and hasattr(instance, '_old_instance'):
                changes = get_field_changes(instance._old_instance, instance)
            
            log_audit(action, instance, changes)
        
        # post_delete: 削除を記録
        @receiver(post_delete, sender=model, weak=False)
        def model_post_delete(sender, instance, **kwargs):
            log_audit('DELETE', instance)
python
# backend/common/apps.py (新規作成)
from django.apps import AppConfig

class CommonConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'common'
    
    def ready(self):
        from .signals import register_audit_signals
        register_audit_signals()  # ⭐ 全モデルに適用
python
# settings.py
INSTALLED_APPS = [
    ...
    'common',  # ⭐ 追加
]
📊 出力例
json
{"timestamp": "2025-10-19 16:00:00", "user": "9999", "action": "CREATE", "model": "Product", "object_id": 123, "ip": "192.168.1.100", "changes": {}, "message": "product CREATE: 123"}
{"timestamp": "2025-10-19 16:01:00", "user": "9999", "action": "UPDATE", "model": "Order", "object_id": 456, "ip": "192.168.1.100", "changes": {"status": {"old": "pending", "new": "shipped"}}, "message": "order UPDATE: 456"}
{"timestamp": "2025-10-19 16:02:00", "user": "9999", "action": "DELETE", "model": "Product", "object_id": 789, "ip": "192.168.1.100", "changes": {}, "message": "product DELETE: 789"}
⚠️ 注意点
パフォーマンス: 全モデルで発火するから、高トラフィック環境では要注意
非同期化: Celeryでバックグラウンド処理にするのも検討
除外設定: EXCLUDE_MODELSで不要なモデルは除外
これで全モデルが監視されるよ！(｀･ω･´)b


get系のセーフメソッドって基本ログ不要かな？

場合による！ セキュリティ要件次第だね(´・ω・｀)

🎯 判断基準
✅ GETログが不要なケース
一般的な閲覧（商品一覧、ニュース表示など）
高頻度アクセス（パフォーマンス優先）
内部的なヘルスチェック、メタデータ取得
⚠️ GETログが必要なケース
1. 個人情報・機密情報の閲覧
   → 誰がいつ顧客情報を見たか

2. 重要データのエクスポート
   → CSV/PDFダウンロード

3. 検索・フィルタリング
   → 不正な情報収集の検知

4. 管理画面での閲覧
   → 管理者の操作履歴

5. コンプライアンス要件
   → GDPR、個人情報保護法、医療系など
📝 実装例：選択的GETログ
python
# backend/config/middleware.py

class AuditMiddleware(MiddlewareMixin):
    """API監査ミドルウェア"""
    
    # ⭐ GET記録が必要なパス（重要データ）
    AUDIT_GET_PATHS = [
        '/api/users/',           # ユーザー情報閲覧
        '/api/customers/',       # 顧客情報閲覧
        '/api/reports/export/',  # レポートDL
        '/api/admin/',           # 管理画面
    ]
    
    # ⭐ POST/PUT/PATCH/DELETE記録が必要なパス
    AUDIT_WRITE_PATHS = [
        '/api/auth/login/',
        '/api/auth/logout/',
        '/api/users/',
        '/api/customers/',
        '/api/orders/',
    ]
    
    # 除外パス
    EXCLUDE_PATHS = [
        '/api/health/',
        '/api/csrf/',
        '/api/products/',  # ⭐ 商品一覧は記録しない
    ]
    
    def _should_audit(self, request):
        """監査対象かチェック"""
        # 除外パス
        if any(request.path.startswith(path) for path in self.EXCLUDE_PATHS):
            return False
        
        # GETの場合：重要パスのみ記録
        if request.method == 'GET':
            return any(request.path.startswith(path) for path in self.AUDIT_GET_PATHS)
        
        # 書き込み系：対象パスを記録
        if request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:
            return any(request.path.startswith(path) for path in self.AUDIT_WRITE_PATHS)
        
        return False
    
    def process_response(self, request, response):
        """レスポンス後処理"""
        if not hasattr(request, '_audit_data'):
            return response
        
        audit_data = request._audit_data
        
        # ⭐ GET操作のログ
        if request.method == 'GET':
            self._log_audit(
                user=audit_data['user'],
                action='READ',  # ⭐ GETはREAD
                model=self._extract_model_name(request.path),
                ip=audit_data['ip'],
                message=f'READ {request.path}',
                extra={
                    'status_code': response.status_code,
                    'query_params': dict(request.GET),  # ⭐ 検索条件も記録
                }
            )
        
        # ... (以下、既存のPOST/PUT/PATCH/DELETE処理)
        
        return response
📊 出力例
json
// ⭐ 重要データの閲覧
{"timestamp": "2025-10-19 16:00:00", "user": "9999", "action": "READ", "model": "User", "object_id": null, "ip": "192.168.1.100", "changes": {"status_code": 200, "query_params": {"is_active": "true"}}, "message": "READ /api/users/?is_active=true"}

// ⭐ CSVエクスポート
{"timestamp": "2025-10-19 16:01:00", "user": "9999", "action": "READ", "model": "Report", "object_id": null, "ip": "192.168.1.100", "changes": {"status_code": 200, "query_params": {"format": "csv", "date_from": "2025-01-01"}}, "message": "READ /api/reports/export/?format=csv"}

// ⭐ 商品一覧は記録されない（除外設定）
// (ログなし)
🔥 高度な制御：Decoratorで個別設定
python
# backend/common/decorators.py
from functools import wraps
import logging

audit_logger = logging.getLogger('audit')

def audit_read(model_name=None):
    """GETメソッドを監査するデコレーター"""
    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            response = view_func(request, *args, **kwargs)
            
            # 成功時のみ記録
            if 200 <= response.status_code < 300:
                from common.context import get_current_request, get_client_ip
                
                user_info = 'anonymous'
                if request.user.is_authenticated:
                    user_info = request.user.employee_id
                
                audit_logger.info(
                    f'READ {model_name or "unknown"}',
                    extra={
                        'user': user_info,
                        'action': 'READ',
                        'model': model_name or 'Unknown',
                        'object_id': kwargs.get('pk'),
                        'ip': get_client_ip(request),
                        'changes': '{}',
                    }
                )
            
            return response
        return wrapper
    return decorator
python
# backend/users/views.py
from rest_framework import viewsets
from common.decorators import audit_read

class UserViewSet(viewsets.ModelViewSet):
    
    @audit_read(model_name='User')  # ⭐ 個別に監査ON
    def retrieve(self, request, *args, **kwargs):
        """ユーザー詳細取得（監査あり）"""
        return super().retrieve(request, *args, **kwargs)
    
    def list(self, request, *args, **kwargs):
        """ユーザー一覧（監査なし）"""
        return super().list(request, *args, **kwargs)
🎯 推奨設定
データ種別	GET記録	理由
個人情報	✅ 必須	コンプライアンス
顧客データ	✅ 必須	不正閲覧検知
管理画面	✅ 必須	管理者監視
エクスポート	✅ 必須	データ持ち出し検知
商品一覧	❌ 不要	公開情報
ニュース	❌ 不要	高頻度アクセス
ヘルスチェック	❌ 不要	ノイズ
結論: 重要データだけGETログを残す設定が現実的だよ！(｀･ω･´)b


*************************************************************************************


うーん(´・ω・｀)じゃあそもそもテンプレートプロジェクトとしてつくるなら、どこまでが正解なんだろ？一旦全モデル記録の方式で、
不要になったら「除外設定: EXCLUDE_MODELSで不要なモデルは除外」する感じ？

その考え方が正解！(｀･ω･´)b

テンプレートプロジェクトなら デフォルトは厳しめ → 後で緩める が鉄則だよ

🎯 テンプレートプロジェクトの設計方針
原則: セキュアバイデフォルト（Secure by Default）

✅ 最初から全部記録
   → プロジェクト開始時は監査厳しめ
   → 後でパフォーマンス見ながら除外

❌ 最初は記録なし
   → 後から「あれ記録してなかった！」が致命的
   → セキュリティインシデント時に証跡なし
📁 テンプレートプロジェクト推奨構成
python
# backend/config/audit_settings.py
"""
監査設定（プロジェクトごとにカスタマイズ）
"""

# ==================== モデル監査設定 ====================

# ⭐ デフォルト: 全モデル記録
AUDIT_ALL_MODELS = True

# ⭐ 除外モデル（必要最小限）
AUDIT_EXCLUDE_MODELS = [
    # Django内部モデル
    'contenttypes.ContentType',
    'sessions.Session',
    'admin.LogEntry',
    
    # 高頻度更新モデル（パフォーマンス考慮）
    # 'analytics.PageView',  # 例: アクセスログ
    # 'notifications.Notification',  # 例: 通知
]

# ⭐ 機密フィールド（マスク対象）
AUDIT_SENSITIVE_FIELDS = [
    'password',
    'token',
    'secret_key',
    'api_key',
    'access_token',
    'refresh_token',
]

# ==================== API監査設定 ====================

# ⭐ GETメソッド記録設定
AUDIT_GET_REQUESTS = True  # デフォルト: 全GET記録

# ⭐ GET記録が必須のパス（AUDIT_GET_REQUESTS=Falseでもこれは記録）
AUDIT_GET_REQUIRED_PATHS = [
    '/api/users/',
    '/api/customers/',
    '/api/admin/',
    '/api/*/export/',  # エクスポート系
]

# ⭐ 完全除外パス（記録しない）
AUDIT_EXCLUDE_PATHS = [
    '/api/health/',
    '/api/csrf/',
    '/api/schema/',
    '/api/docs/',
]

# ⭐ 書き込み系は常に記録（変更不可）
AUDIT_WRITE_METHODS = ['POST', 'PUT', 'PATCH', 'DELETE']

# ==================== ログ出力設定 ====================

# ⭐ ログファイルサイズ・保持数
AUDIT_LOG_MAX_BYTES = 10 * 1024 * 1024  # 10MB
AUDIT_LOG_BACKUP_COUNT = 30  # 30世代（約300MB）

# ⭐ ログレベル
AUDIT_LOG_LEVEL = 'INFO'

# ⭐ 開発環境ではコンソールにも出力
AUDIT_LOG_TO_CONSOLE = False  # 本番はFalse推奨
🔧 実装：設定ファイルを読み込む
python
# backend/common/signals.py
import logging
import json
from django.apps import apps
from django.db.models.signals import post_save, post_delete, pre_save
from django.dispatch import receiver
from django.conf import settings
from common.context import get_current_request, get_client_ip

audit_logger = logging.getLogger('audit')

# ⭐ 設定を読み込み（デフォルト値あり）
AUDIT_ALL_MODELS = getattr(settings, 'AUDIT_ALL_MODELS', True)
EXCLUDE_MODELS = getattr(settings, 'AUDIT_EXCLUDE_MODELS', [])
SENSITIVE_FIELDS = getattr(settings, 'AUDIT_SENSITIVE_FIELDS', ['password', 'token'])


def should_audit(model):
    """監査対象かチェック"""
    if not AUDIT_ALL_MODELS:
        return False
    
    model_label = f"{model._meta.app_label}.{model._meta.model_name}"
    return model_label not in EXCLUDE_MODELS


# ... (以下、前回のコード)
python
# backend/config/middleware.py
from django.conf import settings

class AuditMiddleware(MiddlewareMixin):
    """API監査ミドルウェア"""
    
    def __init__(self, get_response):
        super().__init__(get_response)
        
        # ⭐ 設定を読み込み
        self.audit_get = getattr(settings, 'AUDIT_GET_REQUESTS', True)
        self.get_required_paths = getattr(settings, 'AUDIT_GET_REQUIRED_PATHS', [])
        self.exclude_paths = getattr(settings, 'AUDIT_EXCLUDE_PATHS', [])
        self.write_methods = getattr(settings, 'AUDIT_WRITE_METHODS', 
                                     ['POST', 'PUT', 'PATCH', 'DELETE'])
    
    def _should_audit(self, request):
        """監査対象かチェック"""
        # 除外パス
        if any(request.path.startswith(path) for path in self.exclude_paths):
            return False
        
        # 書き込み系は常に記録
        if request.method in self.write_methods:
            return True
        
        # GETの場合
        if request.method == 'GET':
            # 全GET記録モード
            if self.audit_get:
                return True
            # 重要パスのみ記録
            return any(request.path.startswith(path) for path in self.get_required_paths)
        
        return False
python
# backend/config/settings.py
from .audit_settings import *  # ⭐ 監査設定をインポート

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    
    'formatters': {
        'audit_json': {
            '()': 'common.formatters.AuditJSONFormatter',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
    },
    
    'handlers': {
        'audit_file': {
            'level': AUDIT_LOG_LEVEL,  # ⭐ 設定から読み込み
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'audit.log',
            'maxBytes': AUDIT_LOG_MAX_BYTES,  # ⭐ 設定から読み込み
            'backupCount': AUDIT_LOG_BACKUP_COUNT,  # ⭐ 設定から読み込み
            'formatter': 'audit_json',
        },
    },
    
    'loggers': {
        'audit': {
            'handlers': ['audit_file'],
            'level': AUDIT_LOG_LEVEL,
            'propagate': False,
        },
    },
}

# ⭐ 開発環境ではコンソールにも出力
if DEBUG and AUDIT_LOG_TO_CONSOLE:
    LOGGING['loggers']['audit']['handlers'].append('console')
📝 README.md に使い方を書く
markdown
# 監査ログ設定

## デフォルト動作
- ✅ 全モデルのCRUD操作を記録
- ✅ 全APIリクエスト（GET含む）を記録
- ✅ ログファイル: `logs/audit.log`（10MB × 30世代）

## カスタマイズ方法

### 1. 高頻度モデルを除外する
```python
# config/audit_settings.py
AUDIT_EXCLUDE_MODELS = [
    'analytics.PageView',  # アクセスログは除外
    'notifications.Notification',  # 通知は除外
]
```

### 2. GETリクエストを記録しない
```python
# config/audit_settings.py
AUDIT_GET_REQUESTS = False  # GETは記録しない

# ただし重要パスは記録
AUDIT_GET_REQUIRED_PATHS = [
    '/api/users/',
    '/api/customers/',
]
```

### 3. 完全に監査を無効化（非推奨）
```python
# config/audit_settings.py
AUDIT_ALL_MODELS = False  # モデル監査OFF

# settings.py
MIDDLEWARE = [
    # 'config.middleware.AuditMiddleware',  # コメントアウト
]
```

## パフォーマンスチューニング

本番環境で負荷が高い場合：
1. `AUDIT_GET_REQUESTS = False` にする
2. 高頻度モデルを `AUDIT_EXCLUDE_MODELS` に追加
3. Celeryで非同期ログ出力を検討

## ログ分析
```bash
# 今日のログイン
cat logs/audit.log | jq 'select(.action == "LOGIN")' | jq -r '[.timestamp, .user] | @csv'

# ユーザー9999の操作履歴
cat logs/audit.log | jq 'select(.user == "9999")'

# エラーのあった操作
cat logs/audit.log | jq 'select(.changes | contains("error"))'
```
```

---

## 🎯 段階的な運用例
```
=== プロジェクト開始時（厳しめ） ===
AUDIT_ALL_MODELS = True
AUDIT_GET_REQUESTS = True
→ 全部記録してセキュリティ優先

↓ （数週間運用）

=== 負荷が出てきたら（調整） ===
AUDIT_EXCLUDE_MODELS = [
    'analytics.PageView',  # 1日100万件とか
]
AUDIT_GET_REQUESTS = False  # 必要なパスだけ
→ パフォーマンス改善

↓ （安定運用）

=== 本番リリース後（最適化） ===
必要な監査だけ残して
不要なログは削減
→ コスト削減
✅ 結論
テンプレートプロジェクトなら：

python
# ⭐ デフォルト設定（厳しめ）
AUDIT_ALL_MODELS = True          # 全モデル記録
AUDIT_GET_REQUESTS = True        # 全GET記録
AUDIT_EXCLUDE_MODELS = [         # Django内部のみ除外
    'contenttypes.ContentType',
    'sessions.Session',
    'admin.LogEntry',
]
この状態でテンプレート配布 → 各プロジェクトで audit_settings.py をカスタマイズ

これが一番安全で柔軟だよ！(｀･ω･´)b✨












***************************************************************************************


🎯 監査証跡を最後に入れるべき理由
【開発フェーズ】
1. ビジネスロジック実装   ← まずはコア機能
2. API動作確認
3. テスト作成
4. バグ修正
    ↓
5. 監査証跡実装           ← ⭐ 最後にサッと追加

✅ 最後に入れるメリット
1. ロジックが安定してから監査できる
python# ❌ 最初から監査入れると...
def create_user(data):
    audit_log("CREATE_START", data)  # ← バグってたら無駄なログ
    user = User.objects.create(**data)  # ← まだバグってる
    audit_log("CREATE_END", user)
    return user

# ✅ ロジック完成後に監査追加
def create_user(data):
    user = User.objects.create(**data)  # ← 完璧に動く
    return user

# 後からシグナルで自動監査 ← ⭐ コード変更なし！
2. 開発中のノイズログが出ない
bash# 開発中に監査ログがあると...
logs/audit.log (開発環境)
{"action": "CREATE", "user": "test", ...}  # テストデータ
{"action": "DELETE", "user": "test", ...}  # 作り直し
{"action": "CREATE", "user": "test", ...}  # また作り直し
{"action": "UPDATE", "user": "test", ...}  # デバッグ中
...
(10000行のゴミログ)

# ⭐ 最後に入れれば本番準備段階から綺麗なログ
3. パフォーマンス測定が正確
python# 監査なしで測定 → 100ms
# 監査ありで測定 → 120ms
# → 監査のオーバーヘッドは20ms

# ⭐ 最初から入ってると影響が分からない
4. シグナル/ミドルウェアだから後入れが超簡単
python# ⭐ 既存コードに一切触らない
# settings.py に数行追加するだけ

MIDDLEWARE = [
    ...
    'config.middleware.AuditMiddleware',  # ← 追加
]

INSTALLED_APPS = [
    ...
    'common',  # ← シグナル登録
]

# → 全モデル・全APIが監査される！
```

---

## 📋 理想的な開発フロー
```
Phase 1: コア機能開発 (Week 1-4)
├── モデル設計
├── API実装
├── ビジネスロジック
└── 単体テスト

Phase 2: 統合・調整 (Week 5-6)
├── フロントエンド連携
├── E2Eテスト
└── バグ修正

Phase 3: 本番準備 (Week 7-8)
├── ⭐ 監査証跡追加        ← ここ！
├── セキュリティ強化
├── パフォーマンス計測
└── デプロイ準備

Phase 4: リリース
└── 監査ログ監視開始

🚀 最後に入れる時の手順（30分で完了）
bash# 1. ファイル追加（10分）
backend/
├── config/
│   ├── audit_settings.py      # ⭐ 新規
│   └── middleware.py          # ⭐ 新規
├── common/
│   ├── formatters.py          # ⭐ 新規
│   ├── signals.py             # ⭐ 新規
│   └── context.py             # ⭐ 新規
└── logs/                      # ⭐ 新規
    └── .gitignore

# 2. settings.py 修正（5分）
- MIDDLEWARE に追加
- INSTALLED_APPS に 'common' 追加
- LOGGING 設定追加
- audit_settings.py インポート

# 3. 動作確認（15分）
python manage.py runserver
# → APIを叩いてログ出力確認
tail -f logs/audit.log

💡 注意：最後に入れる時のチェックリスト
markdown□ 既存テストが全部通る（監査追加で壊れてない）
□ パフォーマンスが許容範囲（監査のオーバーヘッド < 10%）
□ logs/ ディレクトリの権限OK（書き込み可能）
□ .gitignore に *.log 追加済み
□ 本番環境の設定確認（ログローテーション、保存先）
□ README に監査ログの説明追加

🎯 結論
python# テンプレートプロジェクトの配布方法

【パターンA: 監査なし版】
- シンプルなテンプレート
- 後から docs/audit_setup.md 見て追加

【パターンB: 監査あり版（推奨）】
- デフォルトで監査機能込み
- audit_settings.py で無効化可能
- 「不要なら AUDIT_ALL_MODELS = False」

→ Bの方が「セキュアバイデフォルト」で安全！
開発中は監査OFFで快適 → 本番前にONにする
これが最強の運用だよ！(´・ω・｀)b✨再試行Claudeは現在、生成したコードを実行する機能を持っていません。