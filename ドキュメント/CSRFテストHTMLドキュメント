# Django + DRF + Vue.js セキュリティ完全ガイド 🛡️

## 目次
1. [CSRF攻撃とは](#csrf攻撃とは)
2. [CORS保護の仕組み](#cors保護の仕組み)
3. [二重防御システム](#二重防御システム)
4. [自動送信ボタンで画面遷移する理由](#自動送信ボタンで画面遷移する理由)
5. [ローカル環境 vs 本番環境](#ローカル環境-vs-本番環境)
6. [実装の確認](#実装の確認)

---

## CSRF攻撃とは

### 攻撃シナリオ

```
┌──────────────────────────────────────────────────────────┐
│ ステップ1: ユーザーが正規サイトにログイン                │
└──────────────────────────────────────────────────────────┘
         ユーザー → https://yoursite.com (ログイン成功)
         ブラウザに認証Cookie保存 🍪

┌──────────────────────────────────────────────────────────┐
│ ステップ2: 同じブラウザで悪意あるサイトを訪問            │
└──────────────────────────────────────────────────────────┘
         ユーザー → https://evil.com (罠サイト)
         
         悪意あるHTML:
         <body onload="document.forms[0].submit();">
           <form method="POST" 
                 action="https://yoursite.com/api/auth/logout/">
           </form>
         </body>

┌──────────────────────────────────────────────────────────┐
│ ステップ3: 自動的にリクエスト送信（ユーザー気づかず）    │
└──────────────────────────────────────────────────────────┘
         POST https://yoursite.com/api/auth/logout/
         Cookie: sessionid=abc123  ← ブラウザが自動添付！
         
         ❌ 保護なし: ログアウト成功（被害発生）
         ✅ 保護あり: 403 Forbidden（攻撃失敗）
```

### 被害例
- 勝手にログアウト
- パスワード変更
- 投稿・削除
- 送金処理（オンラインバンキング）
- 個人情報変更

---

## CORS保護の仕組み

### Same-Origin Policy (同一生成元ポリシー)

**ブラウザの基本セキュリティ機構**

```
Origin = スキーム + ホスト + ポート

例:
https://yoursite.com:443  ← これが"オリジン"

同一オリジン ✅:
  https://yoursite.com/api/users
  https://yoursite.com/login

異なるオリジン ❌:
  http://yoursite.com        (スキーム違い)
  https://evil.com           (ホスト違い)
  https://yoursite.com:8080  (ポート違い)
```

### CORSの動作フロー

#### Pattern 1: Simple Request (GET, POST with simple headers)

```
┌─────────────┐                    ┌─────────────┐
│   Browser   │                    │   Server    │
│ (evil.com)  │                    │(yoursite.com)│
└─────────────┘                    └─────────────┘
       │                                   │
       │  GET /api/users/                  │
       │  Origin: https://evil.com         │
       ├──────────────────────────────────>│
       │                                   │
       │                                   │ Django checks:
       │                                   │ - Is "evil.com" in CORS_ALLOWED_ORIGINS?
       │                                   │ ❌ NO!
       │                                   │
       │  403 Forbidden                    │
       │  (No CORS headers)                │
       │<──────────────────────────────────┤
       │                                   │
       │                                   │
   ブラウザがレスポンスをブロック 🚫
   JavaScriptからアクセス不可
```

#### Pattern 2: Preflight Request (POST/PUT/DELETE with custom headers)

```
┌─────────────┐                    ┌─────────────┐
│   Browser   │                    │   Server    │
│ (evil.com)  │                    │(yoursite.com)│
└─────────────┘                    └─────────────┘
       │                                   │
       │  ① Preflight (自動送信)           │
       │  OPTIONS /api/auth/logout/        │
       │  Origin: https://evil.com         │
       │  Access-Control-Request-Method: POST │
       │  Access-Control-Request-Headers: X-CSRFToken │
       ├──────────────────────────────────>│
       │                                   │
       │                                   │ Django checks:
       │                                   │ - evil.com allowed? ❌
       │                                   │
       │  403 Forbidden                    │
       │  (No CORS headers)                │
       │<──────────────────────────────────┤
       │                                   │
   ブラウザが本リクエストを送信しない 🛑
   攻撃失敗！
```

#### Pattern 3: 許可されたオリジン (正規リクエスト)

```
┌─────────────┐                    ┌─────────────┐
│   Browser   │                    │   Server    │
│(yoursite.com)│                   │(yoursite.com)│
└─────────────┘                    └─────────────┘
       │                                   │
       │  OPTIONS /api/users/              │
       │  Origin: https://yoursite.com     │
       ├──────────────────────────────────>│
       │                                   │
       │                                   │ Django checks:
       │                                   │ - yoursite.com allowed? ✅ YES!
       │                                   │
       │  200 OK                           │
       │  Access-Control-Allow-Origin: https://yoursite.com │
       │  Access-Control-Allow-Methods: GET, POST, PUT, DELETE │
       │  Access-Control-Allow-Credentials: true │
       │<──────────────────────────────────┤
       │                                   │
       │  ② 本リクエスト                   │
       │  POST /api/users/                 │
       │  Origin: https://yoursite.com     │
       │  X-CSRFToken: abc123              │
       ├──────────────────────────────────>│
       │                                   │
       │  200 OK                           │
       │  { "success": true }              │
       │<──────────────────────────────────┤
       │                                   │
   成功！データ取得可能 ✅
```

---

## 二重防御システム

あなたのアプリケーションは**CORS + CSRF**の二重防御で守られています！

```
┌────────────────────────────────────────────────────────────┐
│               攻撃リクエストの防御メカニズム                │
└────────────────────────────────────────────────────────────┘

  悪意あるサイト (https://evil.com)
         │
         ├─ Pattern 1: Fetch API (CSRFトークンなし)
         │      │
         │      ▼
         │  【第一の壁: CORS Preflight】
         │      │
         │      ├─ OPTIONS /api/auth/logout/
         │      │  Origin: https://evil.com
         │      │
         │      └─ Django: "evil.com is not allowed"
         │         → 403 Forbidden (CORS headers なし)
         │         → ブラウザが本リクエストをブロック 🚫
         │
         ├─ Pattern 2: Fetch API (偽CSRFトークン)
         │      │
         │      ▼
         │  【第一の壁: CORS Preflight】
         │      │
         │      └─ 同様にブロック 🚫
         │
         └─ Pattern 3: HTML Form (自動送信)
                │
                ▼
            【CORS Preflightをバイパス】
            ※ Form送信はSimple Requestのため
            Preflightが発生しない
                │
                ▼
            【第二の壁: CSRF検証】
                │
                ├─ POST /api/auth/logout/
                │  Cookie: sessionid=abc123
                │  (CSRFトークンなし)
                │
                └─ Django CsrfViewMiddleware:
                   "CSRFトークンが見つかりません"
                   → 403 Forbidden 🛡️

┌────────────────────────────────────────────────────────────┐
│                  結論: すべての攻撃をブロック                │
└────────────────────────────────────────────────────────────┘
```

### 防御レイヤーの役割分担

| 攻撃タイプ | CORS保護 | CSRF保護 | 結果 |
|-----------|---------|---------|------|
| Fetch/XMLHttpRequest (異なるオリジン) | ✅ ブロック | - | 🛡️ 安全 |
| Form送信 (異なるオリジン) | ⚠️ バイパス可能 | ✅ ブロック | 🛡️ 安全 |
| 正規リクエスト (同じオリジン) | ✅ 許可 | ✅ 許可 | ✅ 成功 |

**重要ポイント:**
- CORS: JavaScript経由のリクエストを制御
- CSRF: すべてのstate-changing操作（POST/PUT/DELETE）を保護
- 両方必要な理由: Form送信はCORSをバイパスするため

---

## 自動送信ボタンで画面遷移する理由

### なぜPattern 3だけDjangoの画面に遷移するのか？

#### 技術的な理由

```javascript
// Pattern 1, 2, 4: Fetch API使用
fetch('http://localhost:8000/api/auth/logout/', {
    method: 'POST',
    credentials: 'include'
});
// → Preflight (OPTIONS) → 403 → ブラウザがブロック
// → JavaScriptのエラーとして処理
// → 画面遷移なし ✅

// Pattern 3: HTML Form送信
<form method="POST" action="http://localhost:8000/api/auth/logout/">
</form>
document.forms[0].submit();
// → 直接POSTリクエスト送信
// → ブラウザが遷移を試みる
// → Djangoが403を返す
// → その403ページがブラウザに表示される 📄
```

#### 挙動の違い

```
┌──────────────────────────────────────────────────────────┐
│ Fetch API (Pattern 1, 2, 4)                              │
└──────────────────────────────────────────────────────────┘

ブラウザの動作:
  1. JavaScript fetch() を実行
  2. Preflight (OPTIONS) 送信
  3. サーバーが 403 を返す
  4. ブラウザが本リクエストをキャンセル
  5. JavaScriptにエラーを返す
  6. **画面は変わらない** ← 現在のページにとどまる
  
コンソール出力:
  ✗ Access to fetch at '...' has been blocked by CORS policy

┌──────────────────────────────────────────────────────────┐
│ HTML Form送信 (Pattern 3)                                 │
└──────────────────────────────────────────────────────────┘

ブラウザの動作:
  1. form.submit() を実行
  2. **ページ全体を遷移**（昔ながらのWeb動作）
  3. POST /api/auth/logout/ にナビゲート
  4. サーバーが 403 を返す
  5. **その403ページを表示** ← ここが違う！
  
表示される画面:
  Django REST framework
  Logout Api
  HTTP 403 Forbidden
  {"detail": "認証情報が含まれていません。"}
```

### なぜこの違いがあるのか？

**歴史的背景:**

```
📜 1990年代〜2000年代初期: 従来のWeb
   - Form送信 = ページ全体をリロード
   - <form action="..."> → ブラウザが遷移
   
🚀 2005年〜: AJAX/Fetch時代
   - JavaScript経由のリクエスト
   - ページ遷移なし
   - CORS保護が必要に
```

**Form送信の特性:**
- ブラウザのネイティブ機能
- JavaScriptなしで動作
- `action`属性のURLに**ナビゲート**する
- レスポンスがHTMLなら表示、JSONでも表示

---

## ローカル環境 vs 本番環境

### ローカル環境での動作（現在）

```python
# backend/config/settings.py (開発環境)

CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vue.jsフロントエンド
]

CSRF_TRUSTED_ORIGINS = [
    "http://localhost:5173",
]

# ⚠️ 開発用設定（本番では危険）
DEBUG = True
SESSION_COOKIE_SECURE = False  # HTTPでも動作
CSRF_COOKIE_SECURE = False     # HTTPでも動作
```

#### テスト結果の解釈

```
テストHTML: file:///C:/Users/.../CSRFテスト.html
Origin: null  ← ファイルシステムから開いたため

Pattern 1-2, 4 (Fetch API):
  ❌ CORS Error: origin 'null' is not in CORS_ALLOWED_ORIGINS
  → Preflightで拒否
  → 攻撃失敗 ✅

Pattern 3 (Form送信):
  → Form送信は直接POST
  → Django画面に遷移
  ❌ 403 Forbidden: "認証情報が含まれていません"
  → CSRFトークンがないため拒否
  → 攻撃失敗 ✅
```

### 本番環境での動作（HTTPS）

```python
# backend/config/settings.py (本番環境)

# 🔐 本番ドメイン設定
CORS_ALLOWED_ORIGINS = [
    "https://yoursite.com",      # 本番フロントエンド
]

CSRF_TRUSTED_ORIGINS = [
    "https://yoursite.com",
]

# 🔒 セキュリティ設定
DEBUG = False
SESSION_COOKIE_SECURE = True     # HTTPS必須
SESSION_COOKIE_HTTPONLY = True   # JavaScriptから読めない
SESSION_COOKIE_SAMESITE = "Lax"  # CSRF保護強化

CSRF_COOKIE_SECURE = True        # HTTPS必須
CSRF_COOKIE_HTTPONLY = False     # JSから読む必要あり
CSRF_COOKIE_SAMESITE = "Lax"     # CSRF保護強化

# 🛡️ セキュリティヘッダー
SECURE_HSTS_SECONDS = 31536000   # 1年間HTTPS強制
SECURE_SSL_REDIRECT = True        # HTTPを自動的にHTTPSへ
```

#### 本番環境での攻撃シナリオ

```
┌──────────────────────────────────────────────────────────┐
│ シナリオ: ユーザーがhttps://evil.comを訪問                │
└──────────────────────────────────────────────────────────┘

悪意あるサイト: https://evil.com
ターゲット: https://yoursite.com

【防御レイヤー1: CORS】
  OPTIONS https://yoursite.com/api/auth/logout/
  Origin: https://evil.com
  
  Django Response:
    403 Forbidden
    (Access-Control-Allow-Originヘッダーなし)
  
  → ブラウザがブロック 🚫

【防御レイヤー2: SameSite Cookie】
  Form送信の場合でも:
  
  POST https://yoursite.com/api/auth/logout/
  Cookie: sessionid=abc123; SameSite=Lax
  
  → ブラウザが自動的にCookieを**送信しない**！
  → セッション認証失敗
  → 401 Unauthorized 🛡️

【防御レイヤー3: CSRF Token】
  万が一Cookieが送信されても:
  
  → CSRFトークンがない
  → 403 Forbidden 🛡️

【防御レイヤー4: HTTPS + HSTS】
  HTTP経由の攻撃:
  
  → 自動的にHTTPSへリダイレクト
  → MitM攻撃を防止 🔒
```

### ローカル vs 本番の比較表

| 項目 | ローカル | 本番 | 理由 |
|-----|---------|------|------|
| プロトコル | HTTP | HTTPS | 本番は暗号化必須 |
| CORS保護 | ✅ 有効 | ✅ 有効 | 両環境で必須 |
| CSRF保護 | ✅ 有効 | ✅ 有効 | 両環境で必須 |
| SameSite Cookie | ⚠️ 無効 | ✅ Lax/Strict | 本番で追加防御 |
| Secure Cookie | ❌ False | ✅ True | HTTPS専用 |
| HSTS | ❌ 無効 | ✅ 有効 | HTTPS強制 |

---

## 実装の確認

### あなたのコードの安全性チェック ✅

#### 1. Axios設定 (frontend/src/plugins/axios.js)

```javascript
// ✅ 良い実装
const api = axios.create({
    baseURL: API_BASE_URL,
    withCredentials: true,  // ← Cookie送信を許可
    timeout: API_TIMEOUT,
});

// ✅ CSRFトークン管理
class CSRFManager {
    async ensureToken() {
        await api.get('auth/csrf/');  // ← トークン取得
        // Cookie反映待ち
        let token = Cookies.get('csrftoken');
        // ...
    }
}

// ✅ リクエストインターセプター
api.interceptors.request.use(async (config) => {
    const methodsRequiringCsrf = ['post', 'put', 'patch', 'delete'];
    
    if (methodsRequiringCsrf.includes(method)) {
        await csrfManager.ensureToken();
        const csrfToken = Cookies.get('csrftoken');
        if (csrfToken) {
            config.headers['X-CSRFToken'] = csrfToken;  // ← ヘッダーに追加
        }
    }
    return config;
});
```

**評価:** 🌟🌟🌟🌟🌟 完璧な実装！

#### 2. Django設定 (backend/config/settings.py)

```python
# ✅ CORS設定
CORS_ALLOW_ALL_ORIGINS = False  # ← 重要！全許可しない
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",     # ← 明示的に許可
]
CORS_ALLOW_CREDENTIALS = True    # ← Cookie許可

# ✅ CSRF設定
MIDDLEWARE = [
    'django.middleware.csrf.CsrfViewMiddleware',  # ← 有効
    # ...
]

CSRF_TRUSTED_ORIGINS = [
    "http://localhost:5173",
]
CSRF_COOKIE_HTTPONLY = False  # ← JSから読む必要あり（これでOK）

# ✅ REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',  # ← CSRF自動チェック
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',  # ← 認証必須
    ],
}
```

**評価:** 🌟🌟🌟🌟🌟 完璧な設定！

### セキュリティレベル診断

```
┌────────────────────────────────────────────┐
│      あなたのアプリのセキュリティレベル      │
└────────────────────────────────────────────┘

✅ CSRF保護            : 有効
✅ CORS保護            : 有効
✅ セッション認証       : 有効
✅ トークン自動管理     : 実装済み
✅ エラーハンドリング   : 実装済み
✅ 認証エラー時自動対応 : 実装済み

⚠️ 本番移行時の要対応:
  [ ] DEBUG = False
  [ ] ALLOWED_HOSTS設定
  [ ] HTTPS (SSL証明書)
  [ ] SESSION_COOKIE_SECURE = True
  [ ] CSRF_COOKIE_SECURE = True
  [ ] SameSite Cookie設定
  [ ] HSTS有効化
  [ ] 本番ドメイン設定

総合評価: A+ (開発環境として完璧)
本番準備度: 80% (設定変更のみで本番対応可能)
```

---

## まとめ

### 🎯 重要ポイント

1. **CORS = JavaScript経由のリクエスト制御**
   - Preflight (OPTIONS) で事前チェック
   - 許可されたオリジンのみアクセス可能

2. **CSRF = すべてのstate-changing操作を保護**
   - Form送信もブロック
   - トークン検証必須

3. **二重防御が必要な理由**
   - CORSだけ: Form送信を防げない
   - CSRFだけ: JavaScript攻撃を防げない
   - 両方: 完全な防御 🛡️

4. **Form送信で画面遷移する理由**
   - ブラウザのネイティブ動作
   - JavaScriptと異なる挙動
   - **本番では問題なし**（攻撃は失敗する）

5. **本番環境ではさらに安全**
   - HTTPS必須
   - SameSite Cookie
   - HSTS
   - Secure Cookie

### 🚀 次のステップ

本番デプロイ時は以下を必ず実施:

```bash
# .env設定
DEBUG=False
ALLOWED_HOSTS=yoursite.com,www.yoursite.com
SECRET_KEY=本番用の強力なキー

# SSL証明書取得 (Let's Encrypt推奨)
# Nginx/Apache設定でHTTPS有効化
# Django設定で本番用セキュリティ設定を有効化
```

**あなたのアプリは正しく実装されています！** ✨

---

## ネットワークタブで見るCORS防御の実際 🔍

### 実際のテスト結果（ブラウザDevTools）

あなたが見たネットワークタブの情報を詳しく解析します！

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
リクエスト一覧（時系列）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. CSRFテスト.html     200  document    12.1 kB   6 ms
   → テストページ読み込み成功 ✅

2. logout/             CORS error  fetch     0.0 kB   25 ms
   → Pattern 1の攻撃失敗 🛡️

3. logout/             200  preflight (OPTIONS)  0.0 kB   23 ms
   → Preflightは成功したが...

4. logout/             CORS error  fetch     0.0 kB   21 ms
   → Pattern 2の攻撃失敗 🛡️

5. logout/             200  preflight (OPTIONS)  0.0 kB   20 ms
   → Preflightは成功したが...

6. me/                 CORS error  fetch     0.0 kB   21 ms
   → Pattern 4の攻撃失敗 🛡️

7. me/                 200  preflight (OPTIONS)  0.0 kB   (時間不明)
   → Preflightは成功したが...
```

### 重要な発見：Preflightが200 OKなのに攻撃失敗！

**一見矛盾しているように見えますが、これが正常な動作です！**

```
┌────────────────────────────────────────────────────────┐
│ なぜPreflight (OPTIONS) が 200 OK なのか？              │
└────────────────────────────────────────────────────────┘

Request:
  OPTIONS http://localhost:8000/api/auth/logout/
  Origin: null  ← ファイルから開いたため
  Access-Control-Request-Method: POST
  Access-Control-Request-Headers: content-type

Django Response:
  Status: 200 OK  ← OPTIONSリクエスト自体は受け付ける
  
  しかし！レスポンスヘッダーを見ると:
  (Access-Control-Allow-Originヘッダーがない！)
  
  ↓
  
ブラウザの判断:
  「Preflightは届いたけど、必要なCORSヘッダーがない」
  → 本リクエストを送信しない 🚫
  → CORS error発生
```

### 詳細なリクエスト/レスポンス分析

#### Pattern 2の例（POST /api/auth/logout/）

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
① Preflight Request (OPTIONS)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Request URL: http://localhost:8000/api/auth/logout/
Request Method: OPTIONS
Status Code: 200 OK

Request Headers:
  Origin: null
  Access-Control-Request-Method: POST
  Access-Control-Request-Headers: content-type,x-csrftoken
  
Response Headers:
  Allow: POST, OPTIONS
  Content-Type: application/json
  Vary: Accept
  
  ⚠️ 注目: 以下のヘッダーが存在しない！
  ✗ Access-Control-Allow-Origin  ← これがない！
  ✗ Access-Control-Allow-Methods
  ✗ Access-Control-Allow-Headers
  ✗ Access-Control-Allow-Credentials

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
② ブラウザの判断
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ブラウザ:
  「OPTIONSは200だけど、CORSヘッダーがないぞ？」
  「origin 'null' は許可されてないな」
  「本リクエスト（POST）を送信するのは危険だ！」
  
  → 本リクエストをキャンセル
  → JavaScriptにCORS errorを返す
  → Console: "Access to fetch at '...' has been blocked by CORS policy"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
③ 本リクエスト（POST）は送信されない
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

この段階に到達しない！
ブラウザがブロック 🛡️
```

### 正規リクエストとの比較

同じエンドポイントでも、正規のフロントエンド（localhost:5173）からなら成功します：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
正規リクエスト（Vue.js → Django）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

① Preflight Request (OPTIONS)

Request Headers:
  Origin: http://localhost:5173  ← 許可されたオリジン
  Access-Control-Request-Method: POST
  Access-Control-Request-Headers: x-csrftoken

Response Headers:
  Access-Control-Allow-Origin: http://localhost:5173  ✅
  Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS  ✅
  Access-Control-Allow-Headers: x-csrftoken, content-type  ✅
  Access-Control-Allow-Credentials: true  ✅
  
  → ブラウザ: 「OK、本リクエストを送信していいぞ」

② 本リクエスト（POST）

Request Headers:
  Origin: http://localhost:5173
  X-CSRFToken: abc123def456...
  Cookie: sessionid=xyz789...

Response:
  200 OK
  { "success": true }
  
  → リクエスト成功！✅
```

### ネットワークタブで確認すべきポイント

#### ✅ 正常な防御が働いている証拠

```
1. Preflightが200 OK
   → Djangoサーバーは稼働している ✅

2. CORSヘッダーがない
   → django-cors-headersが正しくoriginをチェック ✅
   → 許可されていないoriginからのリクエストを拒否 ✅

3. 本リクエストが送信されない
   → ブラウザのCORS保護が機能 ✅

4. Console に CORS error
   → ブラウザが正しくブロックしている ✅
```

#### ❌ もし脆弱性があったら

```
1. Preflightが200 OK
2. CORSヘッダーが含まれている（悪い例）:
   Access-Control-Allow-Origin: *  ← 危険！
   または
   Access-Control-Allow-Origin: null  ← 危険！

3. 本リクエストが送信される
4. 攻撃成功
```

### Pattern 3 (Form送信) のネットワークログ

Form送信の場合はPreflightがありません：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Pattern 3: Form送信のネットワークログ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

logout/    200    document    (サイズ)    (時間)
           ↑
        Form送信は直接POSTを送信
        → PreflightなしでDjangoに到達
        
Django Response:
  403 Forbidden
  Content-Type: text/html
  { "detail": "認証情報が含まれていません。" }
  
  → CSRFトークンがないため拒否 🛡️
  → このHTMLがブラウザに表示される
```

### まとめ：ネットワークタブの読み方

| 項目 | 意味 | 評価 |
|-----|------|------|
| OPTIONS 200 OK | サーバーは稼働中 | ✅ 正常 |
| CORSヘッダーなし | 不正なoriginを拒否 | ✅ 正常 |
| 本リクエスト送信されず | ブラウザがブロック | ✅ 正常 |
| Console: CORS error | 攻撃失敗 | ✅ 正常 |
| Form送信 → 403 | CSRF保護が機能 | ✅ 正常 |

**結論: すべて期待通りの動作です！** 🎉

---

## 参考資料

### 公式ドキュメント
- [Django CSRF Protection](https://docs.djangoproject.com/en/5.2/ref/csrf/)
- [Django REST Framework AJAX/CSRF/CORS](https://www.django-rest-framework.org/topics/ajax-csrf-cors/)
- [MDN: CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
- [MDN: Preflight Request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request)

### セキュリティベストプラクティス
- OWASP CSRF Prevention Cheat Sheet
- OWASP CORS Security Cheat Sheet

### デバッグツール
- Chrome DevTools Network Panel
- Firefox Developer Tools
- Postman (API Testing)



🔍 重要な発見
あなたが見たネットワークログから分かったこと：
OPTIONS 200 OK なのにCORS errorになる理由
OPTIONS → 200 OK  ← これは正常！
  ↓
レスポンスヘッダーをチェック
  ↓
Access-Control-Allow-Origin ヘッダーがない！
  ↓
ブラウザ: 「このoriginは許可されてないな」
  ↓
本リクエスト（POST）をキャンセル 🚫
  ↓
Console: CORS error
これが正しい防御の証です！
多くの人が勘違いするポイント：

❌ 「OPTIONSが200なら成功」← 間違い
✅ 「OPTIONSのレスポンスヘッダーが重要」← 正解

Djangoは「OPTIONSリクエストは受け付けるけど、CORSヘッダーは付けない」という動作で、不正なoriginを拒否しています。
あなたのシステムの防御フロー
悪意あるサイト
  ↓
Preflight (OPTIONS) → 200 OK
  ↓
CORSヘッダーなし！
  ↓
ブラウザがブロック 🛡️
  ↓
攻撃失敗 ✅